# 00. 视C++为一个语言联邦



如今的C++已是一个支持多重范式的编程语言，它支持：面向过程、面向对象、函数式、范型、元编程。

C++的高效编程守则视情况而变化，取决于你使用C++的哪一部分。



# 01. 尽量以const/enum/inline 替换#define



`#define`在预处理时会完成替换过程，所有宏对编译器不可见。

对于单纯常量，最好以`const`对象或者`enum`替换`#define`。

对于形似函数的宏，最好改用`inline`函数替换`#define`



# 02. 尽可能使用const

将某些东西声明为`const`可以帮助编译器检测出错误的用法。`const`可以被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。



编译器强制实施bitwise constness（数据意义的const），但我们编写程序时应使用概念意义上的常量性conceptual constness（逻辑意义上的const）。



当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码充复。



 mutable可以使一个变量在const函数中可以被改变。



# 03. 确定对象被使用前已经先被初始化

为内置型对象进行手工初始化，因为C++并不保证会初始化它们。



构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。

初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。



为避免“跨编译单元之初始化次序问题，以local static对象替换non-local static对象。



## 成员初值列

使用成员初值列时，初始化的顺序应与类内部的变量排列顺序相同，否则会出现bug。

实际上无论初值列的排列顺序如何，成员变量的初始化顺序永远和其排列顺序一样。



# 3-5原则

1.  需要析构函数的类也需要拷贝构造和拷贝赋值函数。
2.  需要拷贝操作的类也需要赋值操作，反之亦然。
3.  析构函数不能是删除的。
4.  如果一个类有删除的或不可访问的析构函数，那么其默认和拷贝构造函数也会被删除。
5.  如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作。

