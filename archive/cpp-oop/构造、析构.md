# 构造函数

> 用于创建对象，开辟空间。



| 函数                      | 使用             | 说明                                         |
| ------------------------- | ---------------- | -------------------------------------------- |
| People();                 | People p;        | 默认构造                                     |
| People(const People &p);  | People p(p2);    | 拷贝构造，不与‘=’等价                        |
| People(std::string name); | People p("ncc"); | 转换构造，逻辑上等于将另一种类型转换为该类型 |



## 原地构造

```
new(void *) People();
```





# 析构函数

> 用于销毁对象，释放空间。

| 函数       | 使用     | 说明     |
| ---------- | -------- | -------- |
| ~People(); | delet p; | 默认析构 |





# 对象生命周期



`构造` -> `使用` -> `销毁`。



# 例





# 返回值优化

代码：

```c++
class CA {...}

CA func() {
  	CA tmp(32);
  	return tmp;
}

int main() {
  	...
    CA ca = func();
    ...
}
```



一般的函数调用过程中的变量生成传递：

1.  在函数的栈中创建一个名为tmp的对象
2.  关键字 `return` 后的`tmp` 表示的用变量`tmp`来构造需要返回的临时对象
3.  函数返回结束，析构掉在函数内建立的所有对象
4.  继续表达式`CA ca = func();`里的操作
5.  语句结束，析构临时对象

如果开启了返回值优化，那么当编译器识别出了 `return`后的返回对象`rvo`和函数的返回对象的类型一致，就会对代码进行优化 。编译器转而会将二者的直接关联在一起，意思就是，对`rvo`的操作就相当于直接对 临时对象的操作。

